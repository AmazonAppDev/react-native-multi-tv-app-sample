<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameLift Streams TV</title>
    <style>
        /* Base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: white;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            min-height: 100vh;
        }
        
        /* Modern Gaming Header */
        .header {
            background: linear-gradient(90deg, rgba(0,0,0,0.9) 0%, rgba(26,26,46,0.8) 100%);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 20px 40px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }
        
        .logo-container {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .brand-text {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* Main Content Area */
        .main-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 100px);
            padding: 40px;
            position: relative;
        }
        
        /* Game Control Panel */
        .game-panel {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .game-title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 12px;
            background: linear-gradient(135deg, #ffffff 0%, #e0e0e0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .game-subtitle {
            font-size: 16px;
            color: rgba(255,255,255,0.7);
            margin-bottom: 40px;
        }
        
        /* Unified Button System */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 18px 36px;
            font-size: 18px;
            font-weight: 600;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            position: relative;
            overflow: hidden;
            min-width: 180px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(44, 62, 80, 0.4);
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(44, 62, 80, 0.6);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.4);
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(231, 76, 60, 0.6);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.4);
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(39, 174, 96, 0.6);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn:disabled {
            background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);
            transform: none;
            box-shadow: none;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .btn-icon {
            font-size: 20px;
        }
        
        /* Loading Spinner */
        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 12px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Controls Container */
        .controls-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        .controls-row {
            display: flex;
            gap: 16px;
            align-items: center;
        }
        
        /* Custom Confirmation Modal */
        .confirmation-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        
        .confirmation-dialog {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        
        .confirmation-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 16px;
            color: white;
        }
        
        .confirmation-message {
            font-size: 18px;
            color: rgba(255,255,255,0.8);
            margin-bottom: 40px;
            line-height: 1.5;
        }
        
        .confirmation-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        
        video::-webkit-media-controls {
            display: none !important;
        }
        
        /* Hidden inputs */
        .hidden {
            display: none !important;
        }
        
        /* Auth Form */
        .auth-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: calc(100vh - 100px);
            padding: 40px;
        }
        
        .auth-form {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 40px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .auth-form h2 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 28px;
            font-weight: 700;
        }
        
        .auth-form input {
            width: 100%;
            padding: 16px 20px;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .auth-form input:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255,255,255,0.15);
        }
        
        .auth-form input::placeholder {
            color: rgba(255,255,255,0.6);
        }
        
        .error-message {
            color: #e74c3c;
            text-align: center;
            margin-bottom: 20px;
            padding: 12px;
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid rgba(231, 76, 60, 0.3);
            border-radius: 8px;
            font-size: 14px;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .header {
                padding: 16px 20px;
            }
            
            .brand-text {
                font-size: 20px;
            }
            
            .game-logo {
                width: 50px;
                height: 50px;
                font-size: 24px;
            }
            
            .main-content {
                padding: 20px;
            }
            
            .game-panel {
                padding: 30px 20px;
            }
            
            .controls-row {
                flex-direction: column;
                gap: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Authentication will be handled here -->
    </div>

    <!-- Load GameLift Streams SDK dynamically -->
    <script>
        console.log('HTML loaded, attempting to load GameLift SDK...');
        
        // Dynamically determine the correct path for the JS file
        (function() {
            const script = document.createElement('script');
            
            // Check if running in Metro dev server (device) or web
            const isMetro = window.location.protocol === 'http:' && 
                           (window.location.hostname === 'localhost' || 
                            window.location.hostname.match(/^\d+\.\d+\.\d+\.\d+$/));
            
            console.log('Loading mode:', isMetro ? 'Metro' : 'Web', 'Location:', window.location.href);
            
            if (isMetro) {
                // For device via Metro - load from public folder
                script.src = `${window.location.protocol}//${window.location.hostname}:8081/gameliftstreams-1.0.0.js`;
            } else {
                // For web build - use relative path
                script.src = './gameliftstreams-1.0.0.js';
            }
            
            console.log('Attempting to load SDK from:', script.src);
            
            script.onload = function() {
                console.log('GameLift SDK loaded successfully');
            };
            
            script.onerror = function() {
                console.error('Failed to load GameLift Streams SDK from:', script.src);
                // Fallback to relative path
                if (isMetro) {
                    console.log('Trying fallback to relative path...');
                    const fallbackScript = document.createElement('script');
                    fallbackScript.src = './gameliftstreams-1.0.0.js';
                    fallbackScript.onload = () => console.log('Fallback SDK loaded');
                    fallbackScript.onerror = () => console.error('Fallback also failed');
                    document.head.appendChild(fallbackScript);
                }
            };
            
            document.head.appendChild(script);
        })();
    </script>
    <script>
        // Configuration - will be set by React Native
        let apiConfig = null;
        let authToken = null;
        
        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            console.log('GameLift Streams TV app starting...');
            
            // Signal that WebView is ready
            setTimeout(() => {
                if (window.ReactNativeWebView) {
                    window.ReactNativeWebView.postMessage(JSON.stringify({type: 'webview-ready'}));
                } else if (window.parent !== window) {
                    window.parent.postMessage(JSON.stringify({type: 'webview-ready'}), '*');
                }
            }, 100);
            
            // Listen for configuration and auth token from React Native
            window.addEventListener('message', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'configure' && data.apiConfig) {
                        apiConfig = data.apiConfig;
                        window.apiConfig = data.apiConfig; // Also set on window for native platform compatibility
                    }
                    
                    if (data.type === 'auth-token' && data.token) {
                        authToken = data.token;
                        window.authToken = data.token; // Also set on window for native platform compatibility
                        
                        // Initialize app when both config and token are received
                        if (apiConfig && authToken) {
                            initializeApp();
                        }
                    }
                    
                    if (data.type === 'game-config' && data.game) {
                        // Auto-fill form with game configuration
                        document.getElementById('sgId').value = data.game.streamGroupId || '';
                        document.getElementById('appId').value = data.game.applicationId || '';
                        document.getElementById('region').value = data.game.region || 'us-west-2';
                        console.log('Game configuration applied:', data.game);
                    }
                    
                    if (data.type === 'check-stream-and-navigate') {
                        // Check if streaming and handle navigation
                        const streamBtn = document.getElementById('stream-btn');
                        const isStreaming = streamBtn && streamBtn.textContent.includes('End Game');
                        
                        if (isStreaming) {
                            showConfirmationModal(
                                'End Game Session',
                                'You have an active game session. Do you want to end it and return to games?',
                                () => {
                                    // User confirmed - end stream
                                    toggleStream();
                                    setTimeout(() => {
                                        if (window.parent !== window) {
                                            window.parent.postMessage(JSON.stringify({type: 'navigate-back'}), '*');
                                        }
                                    }, 1000);
                                },
                                () => {
                                    // User cancelled - do nothing
                                }
                            );
                        } else {
                            // No active stream - navigate immediately
                            if (window.parent !== window) {
                                window.parent.postMessage(JSON.stringify({type: 'navigate-back'}), '*');
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error parsing message:', error);
                }
            });
            
            // Request configuration and token from React Native
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'requestConfig'
                }));
            } else if (window.parent !== window) {
                // For iframe (web platform), post message to parent
                window.parent.postMessage(JSON.stringify({
                    type: 'requestConfig'
                }), '*');
            } else {
                // Show error if no communication method available
                showError('No communication method available. Please check your setup.');
            }
        });
        
        function initializeApp() {
            if (!apiConfig || !authToken) {
                showError('Configuration or authentication not received');
                return;
            }
            
            try {
                console.log('Initializing GameLift Streams app');
                
                // Show the streaming interface directly (no separate auth needed)
                showStreamingInterface();
                
            } catch (error) {
                console.error('Failed to initialize app:', error);
                showError('Failed to initialize: ' + error.message);
            }
        }
        
        function showError(message) {
            document.getElementById('app').innerHTML = `
                <div class="header">
                    <div></div>
                    <div class="logo-container">
                        <div class="brand-text">Amazon GameLift Streams</div>
                    </div>
                </div>
                
                <div class="auth-container">
                    <div class="auth-form">
                        <h2>Configuration Error</h2>
                        <div class="error-message">${message}</div>
                        <p style="text-align: center; color: rgba(255,255,255,0.7); line-height: 1.5;">
                            Please check your AWS configuration and try again.
                        </p>
                    </div>
                </div>
            `;
        }
        
        function showAuthentication() {
            document.getElementById('app').innerHTML = `
                <div class="header">
                    <div></div>
                    <div class="logo-container">
                        <div class="brand-text">Amazon GameLift Streams</div>
                    </div>
                </div>
                
                <div class="auth-container">
                    <div class="auth-form">
                        <h2>Sign In to Play</h2>
                        <div id="auth-error" class="error-message" style="display: none;"></div>
                        <input type="email" id="email" placeholder="Email" required>
                        <input type="password" id="password" placeholder="Password" required>
                        <button onclick="signIn()" id="signin-btn" class="btn btn-primary" style="width: 100%;">
                            <span class="btn-icon">üîê</span>
                            Sign In
                        </button>
                    </div>
                </div>
            `;
        }
        
        async function signIn() {
            const email = document.getElementById('email').value.trim();
            const password = document.getElementById('password').value;
            const errorDiv = document.getElementById('auth-error');
            const signInBtn = document.getElementById('signin-btn');
            
            if (!email || !password) {
                showAuthError('Please enter both email and password');
                return;
            }
            
            signInBtn.disabled = true;
            signInBtn.textContent = 'Signing in...';
            errorDiv.style.display = 'none';
            
            try {
                const result = await window.aws_amplify.signIn({
                    username: email,
                    password: password
                });
                
                if (result.isSignedIn) {
                    console.log('Sign in successful');
                    showStreamingInterface();
                }
                
            } catch (error) {
                console.error('Sign in error:', error);
                showAuthError(error.message || 'Sign in failed');
            } finally {
                signInBtn.disabled = false;
                signInBtn.textContent = 'Sign In';
            }
        }
        
        function showAuthError(message) {
            const errorDiv = document.getElementById('auth-error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }
        
        function showStreamingInterface() {
            document.getElementById('app').innerHTML = `
                <div class="header">
                    <div style="flex: 1;"></div>
                    
                    <div style="display: flex; align-items: center; gap: 20px; flex: 1; justify-content: center;">
                        <!-- Centered controls -->
                        <button onclick="toggleStream()" id="stream-btn" class="btn btn-primary">
                            <span class="btn-icon">‚ñ∂</span>
                            Play Game
                        </button>
                        <div id="spinner" class="spinner" style="display: none;"></div>
                        
                        <div id="fullscreen-container" style="display: none;">
                            <button class="btn btn-success" onclick="enableFullScreen()" id="fullscreen-btn">
                                <span class="btn-icon">‚õ∂</span>
                                Fullscreen
                            </button>
                        </div>
                    </div>
                    
                    <div class="logo-container" style="flex: 1; justify-content: flex-end; display: flex;">
                        <div class="brand-text">Amazon GameLift Streams</div>
                    </div>
                    
                    <!-- Hidden inputs - auto-filled by game config -->
                    <input type="text" id="sgId" class="hidden">
                    <input type="text" id="appId" class="hidden">
                    <select id="region" class="hidden">
                        <option value="ap-northeast-1">ap-northeast-1 (Tokyo)</option>
                        <option value="eu-central-1">eu-central-1 (Frankfurt)</option>
                        <option value="eu-west-1">eu-west-1 (Ireland)</option>
                        <option value="us-east-1">us-east-1 (N. Virginia)</option>
                        <option value="us-east-2">us-east-2 (Ohio)</option>
                        <option value="us-west-2" selected>us-west-2 (Oregon)</option>
                    </select>
                </div>
                
                <div style="width: 100vw; overflow: hidden; position: relative; margin-left: calc(-50vw + 50%); margin-right: calc(-50vw + 50%); padding: 20px;">
                    <video id="StreamVideoElement" autoplay playsinline style="width: 100%; height: auto; display: block;"></video>
                    <audio id="StreamAudioElement" autoplay></audio>
                </div>
            `;
            
            // Wait for SDK to load before initializing (script loads asynchronously)
            const initSDK = () => {
                if (typeof gameliftstreams !== 'undefined') {
                    initializeGameLiftStreams();
                } else {
                    setTimeout(initSDK, 100);
                }
            };
            initSDK();
        }
        
        // Custom confirmation modal for TV-friendly UX
        function showConfirmationModal(title, message, onConfirm, onCancel) {
            const modal = document.createElement('div');
            modal.className = 'confirmation-modal';
            modal.innerHTML = `
                <div class="confirmation-dialog">
                    <h2 class="confirmation-title">${title}</h2>
                    <p class="confirmation-message">${message}</p>
                    <div class="confirmation-buttons">
                        <button class="btn btn-secondary" id="cancel-btn">
                            <span class="btn-icon">‚úï</span>
                            Cancel
                        </button>
                        <button class="btn btn-danger" id="confirm-btn">
                            <span class="btn-icon">‚èπ</span>
                            End Game
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Focus the confirm button by default (TV-friendly)
            const confirmBtn = modal.querySelector('#confirm-btn');
            const cancelBtn = modal.querySelector('#cancel-btn');
            
            confirmBtn.focus();
            
            confirmBtn.onclick = () => {
                document.body.removeChild(modal);
                onConfirm();
            };
            
            cancelBtn.onclick = () => {
                document.body.removeChild(modal);
                onCancel();
            };
            
            // Handle keyboard navigation
            modal.onkeydown = (e) => {
                if (e.key === 'Escape') {
                    document.body.removeChild(modal);
                    onCancel();
                } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    if (document.activeElement === confirmBtn) {
                        cancelBtn.focus();
                    } else {
                        confirmBtn.focus();
                    }
                }
            };
        }
        
        // GameLift Streams implementation (from working sample)
        let gameliftStreams = null;
        let isStreamStarting = false;
        let currentState = 'STOPPED';
        let lastSessionId = '';
        
        function initializeGameLiftStreams() {
            try {
                gameliftStreams = new gameliftstreams.GameLiftStreams({
                    videoElement: document.getElementById('StreamVideoElement'),
                    audioElement: document.getElementById('StreamAudioElement'),
                    inputConfiguration: {
                        setCursor: 'visibility',
                        autoPointerLock: 'fullscreen'
                    },
                    clientConnection: {
                        connectionState: (state) => console.log('Connection state:', state),
                        channelError: (error) => {
                            console.error('Channel error:', error);
                            alert('Channel error: ' + error.message);
                        },
                        serverDisconnect: (reason) => console.log('Server disconnect:', reason)
                    }
                });
                console.log('GameLift Streams SDK initialized');
            } catch (error) {
                console.error('Failed to initialize GameLift Streams SDK:', error);
                alert('Failed to initialize GameLift Streams SDK: ' + error.message);
            }
        }
        
        async function toggleStream() {
            if (currentState === 'RUNNING') {
                stopStream();
            } else {
                await startStream();
            }
        }
        
        async function startStream() {
            const sgId = document.getElementById('sgId').value.trim();
            const appId = document.getElementById('appId').value.trim();
            const region = document.getElementById('region').value;
            
            if (!sgId || !appId) {
                alert('Please enter both Stream Group ID and Application ID');
                return;
            }
            
            if (isStreamStarting) return;
            
            isStreamStarting = true;
            currentState = 'LOADING';
            updateUI();
            
            try {
                const signalRequest = await gameliftStreams.generateSignalRequest();
                
                const payload = {
                    AppIdentifier: appId,
                    SGIdentifier: sgId,
                    SignalRequest: signalRequest,
                    Regions: [region]
                };
                
                const response = await fetch(window.apiConfig.endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${window.authToken}`
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                await waitForACTIVE(data.arn, sgId);
                
            } catch (error) {
                console.error('Failed to start stream:', error);
                alert('Error: ' + (error.message || 'Unknown error'));
                currentState = 'STOPPED';
            } finally {
                isStreamStarting = false;
                updateUI();
            }
        }
        
        async function waitForACTIVE(arn, sg, timeoutMs = 600000) {
            const startTime = Date.now();
            
            while (Date.now() - startTime < timeoutMs) {
                console.log('Waiting for stream session:', arn);
                
                try {
                    const response = await fetch(`${window.apiConfig.endpoint}/session/${encodeURIComponent(sg)}/${encodeURIComponent(arn)}`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${window.authToken}`
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.status === 'ACTIVE') {
                        await startStreamConnection(data.signalResponse);
                        lastSessionId = arn; // Keep for potential future auto-reconnect
                        return;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                } catch (error) {
                    console.error('Error polling session status:', error);
                    throw error;
                }
            }
            
            throw new Error(`Stream session ${arn} did not become active within ${timeoutMs}ms`);
        }
        
        async function startStreamConnection(signalResponse) {
            await gameliftStreams.processSignalResponse(signalResponse);
            gameliftStreams.attachInput();
            currentState = 'RUNNING';
            updateUI();
        }
        
        function stopStream() {
            currentState = 'STOPPED';
            if (gameliftStreams) {
                gameliftStreams.close();
            }
            
            if (document.fullscreenElement) {
                document.exitFullscreen();
            }
            
            initializeGameLiftStreams();
            updateUI();
        }
        
        async function reconnectStream(sessionId) {
            if (!sessionId) {
                console.error('No session ID provided for reconnection');
                return;
            }
            
            if (isStreamStarting) return;
            
            isStreamStarting = true;
            updateUI();
            
            try {
                const signalRequest = await gameliftStreams.generateSignalRequest();
                
                const payload = {
                    SessionIdentifier: sessionId,
                    SignalRequest: signalRequest
                };
                
                const session = await window.aws_amplify.fetchAuthSession();
                const idToken = session.tokens?.idToken?.toString();
                
                const restOperation = window.aws_amplify.post({
                    apiName: 'demo-api',
                    path: '/reconnect',
                    options: {
                        headers: {
                            'Content-Type': 'application/json',
                            Authorization: `Bearer ${idToken}`
                        },
                        body: payload
                    }
                });
                
                const { body } = await restOperation.response;
                const data = JSON.parse(await body.text());
                
                await startStreamConnection(data.signalResponse);
                
            } catch (error) {
                console.error('Failed to reconnect stream:', error);
                alert('Error: ' + (error.message || 'Reconnection failed'));
            } finally {
                isStreamStarting = false;
                updateUI();
            }
        }
        
        function enableFullScreen() {
            const element = document.getElementById('StreamVideoElement');
            if (element && currentState === 'RUNNING') {
                gameliftStreams.attachInput();
                element.requestFullscreen();
                
                if (navigator.keyboard) {
                    navigator.keyboard.lock(["Escape"]);
                }
            }
        }
        
        function updateUI() {
            const streamBtn = document.getElementById('stream-btn');
            const spinner = document.getElementById('spinner');
            const fullscreenContainer = document.getElementById('fullscreen-container');
            
            if (currentState === 'RUNNING') {
                streamBtn.innerHTML = '<span class="btn-icon">‚èπ</span>End Game';
                streamBtn.className = 'btn btn-danger';
                fullscreenContainer.style.display = 'block';
            } else {
                streamBtn.innerHTML = '<span class="btn-icon">‚ñ∂</span>Play Game';
                streamBtn.className = 'btn btn-primary';
                fullscreenContainer.style.display = 'none';
            }
            
            streamBtn.disabled = isStreamStarting;
            spinner.style.display = isStreamStarting ? 'inline-block' : 'none';
        }
    </script>
</body>
</html>
